{
  "name": "Cistern",
  "tagline": "API client framework extracted from Fog",
  "body": "# Cistern\r\n\r\n[![Build Status](https://secure.travis-ci.org/lanej/cistern.png)](http://travis-ci.org/lanej/cistern)\r\n[![Dependencies](https://gemnasium.com/lanej/cistern.png)](https://gemnasium.com/lanej/cistern.png)\r\n[![Gem Version](https://badge.fury.io/rb/cistern.svg)](http://badge.fury.io/rb/cistern)\r\n[![Code Climate](https://codeclimate.com/github/lanej/cistern/badges/gpa.svg)](https://codeclimate.com/github/lanej/cistern)\r\n\r\nCistern helps you consistently build your API clients and faciliates building mock support.\r\n\r\n## Usage\r\n\r\n### Notice: Cistern 3.0\r\n\r\nCistern 3.0 will change the way Cistern interacts with your `Request`, `Collection` and `Model` classes.\r\n\r\nPrior to 3.0, your `Request`, `Collection` and `Model` classes would have inherited from `<service>::Client::Request`, `<service>::Client::Collection` and `<service>::Client::Model` classes, respectively.\r\n\r\nIn cistern `~> 3.0`, the default will be for `Request`, `Collection` and `Model` classes to instead include their respective `<service>::Client` modules.\r\n\r\nIf you want to be forwards-compatible today, you can configure your client by using `Cistern::Client.with`\r\n\r\n```ruby\r\nclass Blog\r\n  include Cistern::Client.with(interface: :module)\r\nend\r\n```\r\n\r\nNow request classes would look like:\r\n\r\n```ruby\r\nclass Blog::GetPost\r\n  include Blog::Request\r\n\r\n  def real\r\n    \"post\"\r\n  end\r\nend\r\n```\r\n\r\n\r\n### Service\r\n\r\nThis represents the remote service that you are wrapping. If the service name is `blog` then a good name is `Blog`.\r\n\r\nService initialization parameters are enumerated by `requires` and `recognizes`. Parameters defined using `recognizes` are optional.\r\n\r\n```ruby\r\n# lib/blog.rb\r\nclass Blog\r\n  include Cistern::Client\r\n\r\n  requires :hmac_id, :hmac_secret\r\n  recognizes :url\r\nend\r\n\r\n# Acceptable\r\nBlog.new(hmac_id: \"1\", hmac_secret: \"2\")                            # Blog::Real\r\nBlog.new(hmac_id: \"1\", hmac_secret: \"2\", url: \"http://example.org\") # Blog::Real\r\n\r\n# ArgumentError\r\nBlog.new(hmac_id: \"1\", url: \"http://example.org\")\r\nBlog.new(hmac_id: \"1\")\r\n```\r\n\r\nCistern will define for you two classes, `Mock` and `Real`. Create the corresponding files and initialzers for your\r\nnew service.\r\n\r\n```ruby\r\n# lib/blog/real.rb\r\nclass Blog::Real\r\n  attr_reader :url, :connection\r\n\r\n  def initialize(attributes)\r\n    @hmac_id, @hmac_secret = attributes.values_at(:hmac_id, :hmac_secret)\r\n    @url = attributes[:url] || 'http://blog.example.org'\r\n    @connection = Faraday.new(url)\r\n  end\r\nend\r\n```\r\n\r\n```ruby\r\n# lib/blog/mock.rb\r\nclass Blog::Mock\r\n  attr_reader :url\r\n\r\n  def initialize(attributes)\r\n    @url = attributes[:url]\r\n  end\r\nend\r\n```\r\n\r\n### Mocking\r\n\r\nCistern strongly encourages you to generate mock support for your service. Mocking can be enabled using `mock!`.\r\n\r\n```ruby\r\nBlog.mocking?          # falsey\r\nreal = Blog.new        # Blog::Real\r\nBlog.mock!\r\nBlog.mocking?          # true\r\nfake = Blog.new        # Blog::Mock\r\nBlog.unmock!\r\nBlog.mocking?          # false\r\nreal.is_a?(Blog::Real) # true\r\nfake.is_a?(Blog::Mock) # true\r\n```\r\n\r\n### Working with data\r\n\r\n`Cistern::Hash` contains many useful functions for working with data normalization and transformation.\r\n\r\n**#stringify_keys**\r\n\r\n```ruby\r\n# anywhere\r\nCistern::Hash.stringify_keys({a: 1, b: 2}) #=> {'a' => 1, 'b' => 2}\r\n# within a Resource\r\nhash_stringify_keys({a: 1, b: 2}) #=> {'a' => 1, 'b' => 2}\r\n```\r\n\r\n**#slice**\r\n\r\n```ruby\r\n# anywhere\r\nCistern::Hash.slice({a: 1, b: 2, c: 3}, :a, :c) #=> {a: 1, c: 3}\r\n# within a Resource\r\nhash_slice({a: 1, b: 2, c: 3}, :a, :c) #=> {a: 1, c: 3}\r\n```\r\n\r\n**#except**\r\n\r\n```ruby\r\n# anywhere\r\nCistern::Hash.except({a: 1, b: 2}, :a) #=> {b: 2}\r\n# within a Resource\r\nhash_except({a: 1, b: 2}, :a) #=> {b: 2}\r\n```\r\n\r\n\r\n**#except!**\r\n\r\n```ruby\r\n# same as #except but modify specified Hash in-place\r\nCistern::Hash.except!({:a => 1, :b => 2}, :a) #=> {:b => 2}\r\n# within a Resource\r\nhash_except!({:a => 1, :b => 2}, :a) #=> {:b => 2}\r\n```\r\n\r\n\r\n### Requests\r\n\r\nRequests are defined by subclassing `#{service}::Request`.\r\n\r\n* `cistern` represents the associated `Blog` instance.\r\n\r\n```ruby\r\nclass Blog::GetPost < Blog::Request\r\n  def real(params)\r\n    # make a real request\r\n    \"i'm real\"\r\n  end\r\n\r\n  def mock(params)\r\n    # return a fake response\r\n    \"imposter!\"\r\n  end\r\nend\r\n\r\nBlog.new.get_post # \"i'm real\"\r\n```\r\n\r\nThe `#cistern_method` function allows you to specify the name of the generated method.\r\n\r\n```ruby\r\nclass Blog::GetPosts < Blog::Request\r\n  cistern_method :get_all_the_posts\r\n\r\n  def real(params)\r\n    \"all the posts\"\r\n  end\r\nend\r\n\r\nBlog.new.respond_to?(:get_posts) # false\r\nBlog.new.get_all_the_posts       # \"all the posts\"\r\n```\r\n\r\nAll declared requests can be listed via `Cistern::Client#requests`.\r\n\r\n```ruby\r\nBlog.requests # => [Blog::GetPosts, Blog::GetPost]\r\n```\r\n\r\n### Models\r\n\r\n* `cistern` represents the associated `Blog::Real` or `Blog::Mock` instance. \r\n* `collection` represents the related collection.\r\n* `new_record?` checks if `identity` is present\r\n* `requires(*requirements)` throws `ArgumentError` if an attribute matching a requirement isn't set\r\n* `requires_one(*requirements)` throws `ArgumentError` if no attribute matching requirement is set\r\n* `merge_attributes(attributes)` sets attributes for the current model instance\r\n* `dirty_attributes` represents attributes changed since the last `merge_attributes`.  This is useful for using `update`\r\n\r\n#### Attributes\r\n\r\nCistern attributes are designed to make your model flexible and developer friendly.\r\n\r\n* `attribute :post_id` adds an accessor to the model.\r\n\t```ruby\r\n\tattribute :post_id\r\n\r\n\tmodel.post_id #=> nil\r\n\tmodel.post_id = 1 #=> 1\r\n\tmodel.post_id #=> 1\r\n\tmodel.attributes #=> {'post_id' => 1 }\r\n\tmodel.dirty_attributes #=> {'post_id' => 1 }\r\n\t```\r\n* `identity` represents the name of the model's unique identifier.  As this is not always available, it is not required.\r\n\t```ruby\r\n\tidentity :name\r\n\t```\r\n\r\n\tcreates an attribute called `name` that is aliased to identity.\r\n\r\n\t```ruby\r\n\tmodel.name = 'michelle'\r\n\r\n\tmodel.identity   #=> 'michelle'\r\n\tmodel.name       #=> 'michelle'\r\n\tmodel.attributes #=> {  'name' => 'michelle' }\r\n\t```\r\n* `:aliases` or `:alias` allows a attribute key to be different then a response key. \r\n\t```ruby\r\n\tattribute :post_id, alias: \"post\"\r\n\t```\r\n\r\n\tallows\r\n\r\n\t```ruby\r\n\tmodel.merge_attributes(\"post\" => 1)\r\n\tmodel.post_id #=> 1\r\n\t```\r\n* `:type` automatically casts the attribute do the specified type. \r\n\t```ruby\r\n\tattribute :private_ips, type: :array\r\n\r\n\tmodel.merge_attributes(\"private_ips\" => 2)\r\n\tmodel.private_ips #=> [2]\r\n\t```\r\n* `:squash` traverses nested hashes for a key. \r\n\t```ruby\r\n\tattribute :post_id, aliases: \"post\", squash: \"id\"\r\n\r\n\tmodel.merge_attributes(\"post\" => {\"id\" => 3})\r\n\tmodel.post_id #=> 3\r\n\t```\r\n\r\n#### Persistence\r\n\r\n* `save` is used to persist the model into the remote service.  `save` is responsible for determining if the operation is an update to an existing resource or a new resource.\r\n* `reload` is used to grab the latest data and merge it into the model.  `reload` uses `collection.get(identity)` by default.\r\n* `update(attrs)` is a `merge_attributes` and a `save`.  When calling `update`, `dirty_attributes` can be used to persist only what has changed locally.\r\n\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass Blog::Post < Blog::Model\r\n  identity :id, type: :integer\r\n\r\n  attribute :body\r\n  attribute :author_id, aliases: \"author\",  squash: \"id\"\r\n  attribute :deleted_at, type: :time\r\n\r\n  def destroy\r\n    requires :identity\r\n\r\n    data = cistern.destroy_post(params).body['post']\r\n  end\r\n\r\n  def save\r\n    requires :author_id\r\n\r\n    response = if new_record?\r\n                 cistern.create_post(attributes)\r\n               else\r\n                 cistern.update_post(dirty_attributes)\r\n               end\r\n\r\n    merge_attributes(response.body['post'])\r\n  end\r\nend\r\n```\r\n\r\nUsage:\r\n\r\n**create**\r\n\r\n```ruby\r\nblog.posts.create(author_id: 1, body: 'text')\r\n```\r\n\r\nis equal to\r\n\r\n```ruby\r\npost = blog.posts.new(author_id: 1, body: 'text')\r\npost.save\r\n```\r\n\r\n**update**\r\n\r\n```ruby\r\npost = blog.posts.get(1)\r\npost.update(author_id: 1) #=> calls #save with #dirty_attributes == { 'author_id' => 1 }\r\npost.author_id #=> 1\r\n```\r\n\r\n### Singular\r\n\r\nSingular resources do not have an associated collection and the model contains the `get` and`save` methods.\r\n\r\nFor instance:\r\n\r\n```ruby\r\nclass Blog::PostData\r\n  include Blog::Singular\r\n\r\n  attribute :post_id, type: :integer\r\n  attribute :upvotes, type: :integer\r\n  attribute :views, type: :integer\r\n  attribute :rating, type: :float\r\n\r\n  def get\r\n    response = cistern.get_post_data(post_id)\r\n    merge_attributes(response.body['data'])\r\n  end\r\n  \r\n  def save\r\n    response = cistern.update_post_data(post_id, dirty_attributes)\r\n    merge_attributes(response.data['data'])\r\n  end\r\nend\r\n```\r\n\r\nSingular resources often hang off of other models or collections.\r\n\r\n```ruby\r\nclass Blog::Post\r\n  include Cistern::Model\r\n\r\n  identity :id, type: :integer\r\n\r\n  def data\r\n    cistern.post_data(post_id: identity).load\r\n  end\r\nend\r\n```\r\n\r\nThey are special cases of Models and have similar interfaces.\r\n\r\n```ruby\r\npost.data.views #=> nil\r\npost.data.update(views: 3)\r\npost.data.views #=> 3\r\n```\r\n\r\n\r\n### Collection\r\n\r\n* `model` tells Cistern which resource class this collection represents.\r\n* `cistern` is the associated `Blog::Real` or `Blog::Mock` instance\r\n* `attribute` specifications on collections are allowed. use `merge_attributes`\r\n* `load` consumes an Array of data and constructs matching `model` instances\r\n\r\n```ruby\r\nclass Blog::Posts < Blog::Collection\r\n\r\n  attribute :count, type: :integer\r\n\r\n  model Blog::Post\r\n\r\n  def all(params = {})\r\n    response = cistern.get_posts(params)\r\n\r\n    data = response.body\r\n\r\n    load(data[\"posts\"])    # store post records in collection\r\n    merge_attributes(data) # store any other attributes of the response on the collection\r\n  end\r\n\r\n  def discover(author_id, options={})\r\n    params = {\r\n      \"author_id\" => author_id,\r\n    }\r\n    params.merge!(\"topic\" => options[:topic]) if options.key?(:topic)\r\n\r\n    cistern.blogs.new(cistern.discover_blog(params).body[\"blog\"])\r\n  end\r\n\r\n  def get(id)\r\n    data = cistern.get_post(id).body[\"post\"]\r\n\r\n    new(data) if data\r\n  end\r\nend\r\n```\r\n\r\n#### Data\r\n\r\nA uniform interface for mock data is mixed into the `Mock` class by default.\r\n\r\n```ruby\r\nBlog.mock!\r\nclient = Blog.new     # Blog::Mock\r\nclient.data                  # Cistern::Data::Hash\r\nclient.data[\"posts\"] += [\"x\"] # [\"x\"]\r\n```\r\n\r\nMock data is class-level by default\r\n\r\n```ruby\r\nBlog::Mock.data[\"posts\"] # [\"x\"]\r\n```\r\n\r\n`reset!` dimisses the `data` object.\r\n\r\n```ruby\r\nclient.data.object_id # 70199868585600\r\nclient.reset!\r\nclient.data[\"posts\"]   # []\r\nclient.data.object_id # 70199868566840\r\n```\r\n\r\n`clear` removes existing keys and values but keeps the same object.\r\n\r\n```ruby\r\nclient.data[\"posts\"] += [\"y\"] # [\"y\"]\r\nclient.data.object_id         # 70199868378300\r\nclient.clear\r\nclient.data[\"posts\"]          # []\r\nclient.data.object_id         # 70199868378300\r\n```\r\n\r\n* `store` and `[]=` write\r\n* `fetch` and `[]` read\r\n\r\nYou can make the service bypass Cistern's mock data structures by simply creating a `self.data` function in your service `Mock` declaration.\r\n\r\n```ruby\r\nclass Blog\r\n  include Cistern::Client\r\n\r\n  class Mock\r\n    def self.data\r\n      @data ||= {}\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n#### Storage\r\n\r\nCurrently supported storage backends are:\r\n\r\n* `:hash` : `Cistern::Data::Hash` (default)\r\n* `:redis` : `Cistern::Data::Redis`\r\n\r\n\r\nBackends can be switched by using `store_in`.\r\n\r\n```ruby\r\n# use redis with defaults\r\nPatient::Mock.store_in(:redis)\r\n# use redis with a specific client\r\nPatient::Mock.store_in(:redis, client: Redis::Namespace.new(\"cistern\", redis: Redis.new(host: \"10.1.0.1\"))\r\n# use a hash\r\nPatient::Mock.store_in(:hash)\r\n```\r\n\r\n\r\n#### Dirty\r\n\r\nDirty attributes are tracked and cleared when `merge_attributes` is called.\r\n\r\n* `changed` returns a Hash of changed attributes mapped to there initial value and current value\r\n* `dirty_attributes` returns Hash of changed attributes with there current value.  This should be used in the model `save` function.\r\n\r\n\r\n```ruby\r\npost = Blog::Post.new(id: 1, flavor: \"x\") # => <#Blog::Post>\r\n\r\npost.dirty?           # => false\r\npost.changed          # => {}\r\npost.dirty_attributes # => {}\r\n\r\npost.flavor = \"y\"\r\n\r\npost.dirty?           # => true\r\npost.changed          # => {flavor: [\"x\", \"y\"]}\r\npost.dirty_attributes # => {flavor: \"y\"}\r\n\r\npost.save\r\npost.dirty?           # => false\r\npost.changed          # => {}\r\npost.dirty_attributes # => {}\r\n```\r\n\r\n### Custom Architecture\r\n\r\nWhen configuring your client, you can use `:collection`, `:request`, and `:model` options to define the name of module or class interface for the service component.\r\n\r\nFor example: if you'd `Request` is to be used for a model, then the `Request` component name can be remapped to `Demand`\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass Blog\r\n  include Cistern::Client.with(interface: :modules, request: \"Demand\")\r\nend\r\n```\r\n\r\nallows a model named `Request` to exist\r\n\r\n```ruby\r\nclass Blog::Request\r\n  include Blog::Model\r\n\r\n  identity :jovi\r\nend\r\n```\r\n\r\nwhile living on a `Demand`\r\n\r\n```ruby\r\nclass Blog::GetPost\r\n  include Blog::Demand\r\n\r\n  def real\r\n    cistern.request.get(\"/wing\")\r\n  end\r\nend\r\n```\r\n\r\n## Examples\r\n\r\n* [zendesk2](https://github.com/lanej/zendesk2)\r\n* [you_track](https://github.com/lanej/you_track)\r\n\r\n## Releasing\r\n\r\n    $ gem bump -trv (major|minor|patch)\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n",
  "google": "UA-36625285-1 Joshua Lane",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}